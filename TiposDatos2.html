<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuevos Tipos de Datos</title>
    <script>
        /*Nuevos tipos de datos en JS*/
        //Vienen a partir del ENMA 6

        /*      Symbols     */
        /*Tipo de dato primitivo, su valor se mantiene
        como privado y para uso interno, suelen usarse
        dentro de los objetos.
        Su sintaxis es la siguiente.
        let x = Symbol();
        */
        //let x = Symbol();
        //let y = Symbol();
        //console.log(x === y);
        /*En el ejemplo anterior, a pesar de que ambas 
        variables sean Symbol, la salida nos marca false
        debido a que cada uno es único, caracteristica
        de este tipo de dato, referencia Unica.*/

        /*Simbolos en objetos*/
        /*Primero declaramos una variable e indicamos que 
        es de tipo Symbol, las buenas practicas mencionan
        que los simbolos deben ser declarados con 
        cosntantes
        */
        //const NOMBRE = Symbol(); //Declaracion de simbolo

        //Creamos nuestro objeto
        // const persona = {
        //     /*Para indicar que una propiedad de nuestro 
        //     objeto es un Symbol, el nombre de la constante
        //     la encerramos en []
        //     */
        //     [NOMBRE]: "Emo"
        // };

        // console.log(persona);
        /*En la salida podemos ver que no sale el nombre
        de la propiedad, sino que sale marcada como Symbol
        y su valor
        */
        
        /*En caso de que añadamos otra propiedad al objeto y llegue a llamarse igual que el simbolo
        aun tendremos la salida anterior, esto debido 
        a la sintaxis de los corchetes que especifican
        que propiedad es Symbol
        */
        // persona.NOMBRE = "Erick";
        // console.log(persona);
        /*Para acceder al valor de un Symbol lo hacemos
        con la sintaxis de los corchetes
        */
        // console.log(persona[NOMBRE]);

        /*Symbol como metodo*/
        /*En la creacion de un Simbol, le podemos pasar
        una string que sirve como "referencia" o "etiqueta"
        a esa propiedad o metodo privado*/
        // const SALUDAR = Symbol("metodo1");
        // persona[SALUDAR] = function(){
        //     console.log("Hola a todos");
        // }
        // console.log(persona);
        // persona[SALUDAR]();
        /*En la salida ya podemos ver la etiqueta del metodo asociada al symbol que especificamos antes*/

        // for(let propiedad in persona){
        //     console.log(propiedad);//nombre de la propiedad
        //     console.log(persona[propiedad]);//valor de la propiedad
        // }
        /*En la salida de este for in solo nos muestra
        las propiedades que NO son Symbol, con esto se 
        refuerza y observa que cualquier propiedad
        de este tipo se mantiene privada, lo cual hace
        atractivo a los Symbol
        */
        /*En dado caso que se quiera saber cuales son 
        esos simbolos usamos el siguiente metodo
            Object.getOwnPropertySymbols(objeto)
        el cual nos devuelve a manera de array los simbolos
        del objeto pasado como parametro identificados 
        con sus respectias etiquetas en caso de tenerlas.
        */
        // console.log(Object.getOwnPropertySymbols(persona));
        
        /*      SETS        */
        /*Es similar a un array, sin embargo con elementos
        unicos. en terminos simples es un Conjunto como en 
        las tuplas en Python
        Dato complejo
        */
        // let conjunto = new Set([1,2,3,3,false,false,{},{},"hola","HOla"]);
        // console.log(conjunto);
        // /*Para conocer el tam de un Set usamos size*/
        // //console.log(conjunto.size);

        // //Agregar valores
        // conjunto.add(20);
        // conjunto.add(20);
        // conjunto.add(30);
        // conjunto.add("30");
        // conjunto.add({});

        //console.log(conjunto.size);

        //Recorrido del conjunto
        // console.log("recorrido 1");
        // for(item of conjunto){
        //     console.log(item);
        // }
        // console.log("recorrido 2");
        // conjunto.forEach(elemento =>{
        //     console.log(elemento);
        // });


        /*Para acceder a los elementos del Set por medio
        de su posicion, de cierta forma hay que convertirlo
        a un arreglo de la siguiente forma*/
        //let pseudoSet = Array.from(conjunto);
        //console.log(pseudoSet[0]);
        
        /*Aqui la variable pseudoSet ya se comporta como
        un arreglo normal*/

        //Eliminar valores
        //conjunto.delete(20);
        //console.log(conjunto);

        /*Comprobacion de la existencia de un dato en el
        conjunto*/
        //console.log(conjunto.has(1));
        /*Eliminacion de todos los elementos del Set*/
        //conjunto.clear();
        //console.log(conjunto);


        // let set1 = new Set([1,2,3,4,5,6,7,8,9,10]);
        // console.log(set1);
        // set1.delete(10);
        // console.log(set1);
        /*Nota: en las salidas de la consola no podemos
        ver los elementos un momento antes y otro momento
        despues de hacer una eliminacion. se muestra UNICAMENTE despues de la eliminacion todo el conjunto*/

        /*      MAPS        */
        /*Objetos que nos sirven para almacenar
        conjunto de valores asociados a manera de objeto.
        similar a un objeto primitivo
        MAP = Dato complejo
        */
        let mapa = new Map();

        //agregar valores al Map en formato clave:valor
        mapa.set("nombre","Jon");
        mapa.set("edad",35);
        mapa.set("email","prueba@gmail.com");
        
        console.log(mapa);
        /*Nota: Pareciera que es un arreglo el dato Map,
        sin embargo es un objeto iterador
        Tambien tiene la propiedada size para su tamaño
        */
        console.log(mapa.size);//tamanio del mapa
        //verificacion de posesion de una propiedad
        console.log(mapa.has("nombre"));
        console.log(mapa.has("apellido"));

        //Obtencion del valor de la clave pasada como parametro
        console.log(mapa.get("nombre"));

        /*Sobre escritura de valores en propiedades*/
        mapa.set("nombre","Erick");
        console.log(mapa.get("nombre"));

        //Eliminacion de propiedad
        mapa.delete("edad");
        console.log(mapa);
        
        /*A diferencia de los Sets, aqui si se puede 
        apreciar el estado del Mapa antes y despues de una
        eliminacion en la consola.
        */

        /*Recorrido del mapa*/
        /*Uso de destructuracion*/
        for(let [llave,valor] of mapa){
            console.log("Llave: "+llave+", Valor: "+valor);
        }

        /*Como se puede apreciar en el Mapa, las propiedades se guardan como cadenas de texto, sin embargo tambien pueden tener otro tipo de dato con
        su respectivo valor como una propiedad
        */
        mapa.set(null,"nulo");
        mapa.set(undefined,"Indefinido -_-");
        mapa.set(19,"Entero");
        console.log(mapa);

        /*Otra forma de inicializar un Mapa*/
        const mapa2 = new Map([
            ["nombre","Atreus"],
            ["Edad",2],
            ["Raza","Husky"]
        ]);
        console.log(mapa2);

        /*Destructuracion para almacenar en un arreglo
        el nombre de todas las llaves del mapa, y en otro
        arreglo guardaremos los valores de cada llave

        Para ello usaremos los metodos keys() y values()
        cada uno de estos metodos devuelve un iterable
        sobre las llaves o valores del mapa que estemos usando

        a continuacion usaremos el operador spread para
        juntar en un solo arreglo todos los elementos
        iterados por los metodos antes mencionados

        */
       const llaves = [...mapa2.keys()];
       const valores = [...mapa2.values()];
       console.log(llaves);
       console.log(valores);
    </script>
</head>
<body>
    <h1>Nuevos Tipos de datos en JS</h1>
    <ul>
        <li>Symbols</li>
        <li>Sets</li>
        <li>Maps</li>
        <li>WeakSets & WeakMaps</li>
        <li>Iterables & Iterators</li>
        <li>Generators</li>
        <!-- <li>Proxies</li> -->

    </ul>
</body>
</html>